# 导入必要的库
import torch
import torchvision
from torchvision.models.detection import fasterrcnn_resnet50_fpn
from torchvision.transforms import transforms
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from google.colab import files
import io
import random  # 新增：用于随机生成寻宝清单
import ipywidgets as widgets  # 新增：用于改善UI交互
from IPython.display import display, clear_output  # 新增：用于显示输出

# 设置设备（GPU或CPU）
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# 加载预训练的Faster R-CNN模型
model = fasterrcnn_resnet50_fpn(pretrained=True)
model.eval()  # 设置为评估模式
model.to(device)  # 将模型移动到设备

# COCO数据集的类别列表（部分常用类别，索引从1开始）
COCO_CLASSES = [
    'N/A', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck',
    'boat', 'traffic light', 'fire hydrant', 'N/A', 'stop sign', 'parking meter', 'bench',
    'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe',
    'N/A', 'backpack', 'umbrella', 'N/A', 'N/A', 'handbag', 'tie', 'suitcase', 'frisbee',
    'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard',
    'surfboard', 'tennis racket', 'bottle', 'N/A', 'wine glass', 'cup', 'fork', 'knife',
    'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog',
    'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'N/A', 'dining table',
    'N/A', 'N/A', 'toilet', 'N/A', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
    'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'N/A', 'book', 'clock', 'vase',
    'scissors', 'teddy bear', 'hair drier', 'toothbrush'
]

# 定义教室常见物体列表（从COCO_CLASSES中筛选适合教室的物体）
CLASSROOM_OBJECTS = [
    'person', 'bench', 'backpack', 'umbrella', 'handbag', 'bottle', 'wine glass', 'cup',
    'fork', 'knife', 'spoon', 'bowl', 'chair', 'couch', 'potted plant', 'dining table',
    'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'book', 'clock', 'vase',
    'scissors'
]

# 图像预处理函数
def preprocess_image(image_bytes):
    image = Image.open(io.BytesIO(image_bytes)).convert("RGB")  # 从字节打开并转换为RGB格式
    transform = transforms.ToTensor()  # 转换为张量
    image_tensor = transform(image).unsqueeze(0)  # 添加batch维度
    return image_tensor.to(device), image

# 目标检测函数
def detect_objects(image_tensor):
    with torch.no_grad():  # 不计算梯度，加速推理
        predictions = model(image_tensor)  # 进行预测
    return predictions[0]  # 返回第一个batch的预测结果

# 可视化检测结果
def plot_detections(image, predictions, score_threshold=0.3):
    fig, ax = plt.subplots(figsize=(10, 8))
    image_np = np.array(image)
    ax.imshow(image_np)

    # 绘制检测框和标签
    for box, label, score in zip(predictions['boxes'], predictions['labels'], predictions['scores']):
        if score > score_threshold:  # 只显示置信度高于阈值的检测
            box = box.cpu().numpy()
            label_id = label.item()
            label_name = COCO_CLASSES[label_id] if label_id < len(COCO_CLASSES) else 'Unknown'
            score = score.item()

            # 绘制边界框
            rect = plt.Rectangle((box[0], box[1]), box[2] - box[0], box[3] - box[1],
                                 linewidth=2, edgecolor='r', facecolor='none')
            ax.add_patch(rect)
            # 添加标签和置信度
            ax.text(box[0], box[1], f'{label_name}: {score:.2f}',
                    bbox=dict(facecolor='white', alpha=0.8))

    ax.axis('off')
    return fig  # 返回fig对象，便于在UI中显示

# 计算寻宝分数并添加调试信息
def calculate_score(predictions, treasure_list, score_threshold=0.3):
    score = 0
    detected_items = []

    # 打印所有检测到的物体和置信度（调试用）
    print("\n所有检测到的物体：")
    for label, conf in zip(predictions['labels'], predictions['scores']):
        label_name = COCO_CLASSES[label.item()] if label.item() < len(COCO_CLASSES) else 'Unknown'
        print(f"- 物体: {label_name}, 置信度: {conf:.2f}")

        if conf > score_threshold:  # 只考虑置信度高于阈值的物体
            if label_name in treasure_list:  # 检查是否在寻宝清单中
                score += treasure_list[label_name]
                detected_items.append((label_name, treasure_list[label_name]))

    return score, detected_items

# 生成随机寻宝清单
def generate_treasure_list(num_items=4):
    selected_objects = random.sample(CLASSROOM_OBJECTS, num_items)  # 随机选4个物体
    treasure_list = {obj: random.randint(5, 20) for obj in selected_objects}  # 为每个分配5-20分的随机分数
    return treasure_list

# 主程序：使用ipywidgets改善UI
def run_treasure_hunt_ui():
    # 生成随机寻宝清单
    treasure_list = generate_treasure_list()

    # UI组件
    output = widgets.Output()  # 输出区域
    upload_button = widgets.FileUpload(accept='image/*', multiple=False, description='上传照片')  # 上传按钮
    run_button = widgets.Button(description='运行检测', button_style='success')  # 运行按钮
    treasure_display = widgets.HTML(value="<b>本次寻宝清单：</b><br>" + "<br>".join([f"{item}: {points} 分" for item, points in treasure_list.items()]))  # 显示清单

    def on_run_clicked(b):
        with output:
            clear_output(wait=True)  # 清空输出
            if not upload_button.value:
                print("请先上传照片！")
                return

            # 获取上传的图片字节
            uploaded_file = next(iter(upload_button.value.values()))
            image_bytes = uploaded_file['content']

            image_tensor, image = preprocess_image(image_bytes)  # 预处理图片
            predictions = detect_objects(image_tensor)  # 进行目标检测

            # 显示可视化结果
            fig = plot_detections(image, predictions)
            plt.show()

            # 计算分数并显示结果
            total_score, detected_items = calculate_score(predictions, treasure_list)
            print("\n检测到的宝物：")
            if detected_items:
                for item, points in detected_items:
                    print(f"- {item}: {points} 分")
                print(f"\n总得分: {total_score} 分")
            else:
                print("未找到清单中的宝物，得分为 0！")

    run_button.on_click(on_run_clicked)  # 绑定按钮事件

    # 显示UI
    display(treasure_display, upload_button, run_button, output)

# 运行游戏UI
run_treasure_hunt_ui()
